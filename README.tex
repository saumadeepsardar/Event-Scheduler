\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{a4paper, margin=1in}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{parskip} % Adds spacing between paragraphs
\usepackage{lipsum} % For filler text to reach 10 pages

% Define colors for code listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configure listings for code
\lstset{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\title{Virtual Event Scheduler with Attendance Insights}
\author{Your Name}
\date{April 2025}

\begin{document}

\maketitle

\section{Introduction}
\subsection{Overview and Purpose}
The \textbf{Virtual Event Scheduler with Attendance Insights} is a full-stack web application designed to manage events efficiently across academic, organizational, or community settings. Built with HTML, CSS, and JavaScript (front-end), Node.js with Express (back-end), and MySQL (database), it supports three user roles—\texttt{student}, \texttt{organizer}, and \texttt{admin}. The project automates event creation, RSVP handling, attendance tracking, and provides analytics, addressing challenges like overbooking and manual record-keeping.

The system’s goals include:
\begin{itemize}
    \item Centralized event scheduling and discovery.
    \item Capacity enforcement with waitlist support.
    \item Real-time attendance tracking.
    \item Feedback collection and attendance insights.
\end{itemize}

\subsection{Significance}
This project is valuable for its efficiency, user engagement, and data-driven insights. It reduces administrative overhead, engages users through an intuitive interface, and provides analytics for assessing event success, making it ideal for university workshops, career fairs, or club meetings.

\subsection{Role of the Database}
The MySQL database (\texttt{EventSchedulerPublic}) is the core of the system:
\begin{itemize}
    \item Stores persistent data across users, events, RSVPs, attendance, and feedback.
    \item Enforces relational integrity with foreign keys.
    \item Enables role-based access via the \texttt{role} column.
    \item Optimizes queries with indexes.
    \item Automates processes like waitlist transitions via triggers.
\end{itemize}

\section{Project Description and Working}
\subsection{Detailed Overview}
The Virtual Event Scheduler enables students to participate in events, organizers to manage them, and admins to oversee the system. It integrates a RESTful API with a MySQL database to deliver features like role-based access, capacity management, waitlist automation, attendance tracking, and analytics. The following subsections detail the code flow and key features in execution order.

\subsection{Code Flow and Key Features}
The application follows a logical sequence from user registration to analytics generation. Below, features are presented in the order they occur in a typical user journey, with code snippets and explanations.

\begin{enumerate}
    \item \textbf{Role-Based Access}
        \begin{itemize}
            \item \textit{Database (SQL)}:
\begin{lstlisting}[language=SQL, caption={Users Table Definition}]
CREATE TABLE Users (
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    role ENUM('student', 'organizer', 'admin') DEFAULT 'student'
);
INSERT INTO Users (user_id, name, email, password_hash, role) 
VALUES (1, 'Admin User', 'admin@example.com', 
    '$2b$10$X7gK8jQJ5vZ8X9zL2wQ8P.vX7Z8X9zL2wQ8P.vX7Z8X9zL2wQ8P', 'admin');
\end{lstlisting}
            \item \textit{Back-End (server.js)}:
\begin{lstlisting}[language=JavaScript, caption={Authentication and Role Check}]
function authenticateToken(req, res, next) {
    const token = req.headers['authorization']?.split(' ')[1];
    if (!token) return res.status(401).json({ error: 'Unauthorized' });
    jwt.verify(token, SECRET_KEY, (err, user) => {
        if (err) return res.status(403).json({ error: 'Forbidden' });
        req.user = user;
        next();
    });
}
app.post('/api/v1/register', async (req, res) => {
    const { name, email, password } = req.body;
    const password_hash = await bcrypt.hash(password, 10);
    const [result] = await db.execute(
        'INSERT INTO Users (name, email, password_hash) VALUES (?, ?, ?)',
        [name, email, password_hash]
    );
    res.status(201).json({ user_id: result.insertId });
});
app.post('/api/v1/admin/users', authenticateToken, async (req, res) => {
    if (req.user.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });
    const { name, email, password, role } = req.body;
    const password_hash = await bcrypt.hash(password, 10);
    const [result] = await db.execute(
        'INSERT INTO Users (name, email, password_hash, role) VALUES (?, ?, ?, ?)',
        [name, email, password_hash, role]
    );
    res.status(201).json({ user_id: result.insertId });
});
\end{lstlisting}
            \item \textit{Front-End (script.js)}:
\begin{lstlisting}[language=JavaScript, caption={Login and Role-Based UI}]
async function handleLogin() {
    const email = document.getElementById('email').value;
    const password = document.getElementById('password').value;
    const response = await fetch('http://localhost:5000/api/v1/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
    });
    const data = await response.json();
    if (response.ok) {
        localStorage.setItem('token', data.token);
        localStorage.setItem('role', data.role);
        window.location.href = 'index.html';
    }
}
function loadDashboard() {
    const role = localStorage.getItem('role');
    if (role === 'organizer' || role === 'admin') {
        document.getElementById('createEventLink').style.display = 'block';
    }
    fetchEvents();
}
\end{lstlisting}
            \item \textit{Function and Working}: 
                This is the entry point. Users register via \texttt{POST /api/v1/register}, storing data in \texttt{Users} with a default \texttt{student} role. Admins add organizers/admins via \texttt{POST /api/v1/admin/users}, restricted by \texttt{authenticateToken}. Login (\texttt{POST /api/v1/login}) authenticates users, issuing a JWT with \texttt{role}. The front-end uses this role to adjust UI visibility (e.g., showing event creation links). Execution starts here, enabling subsequent interactions.
        \end{itemize}

    \item \textbf{Capacity Management}
        \begin{itemize}
            \item \textit{Database (SQL)}:
\begin{lstlisting}[language=SQL, caption={Events and RSVPs Tables}]
CREATE TABLE Events (
    event_id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    date_time DATETIME NOT NULL,
    max_capacity INT NOT NULL,
    organizer_id INT
);
CREATE TABLE Event_RSVPs (
    rsvp_id INT AUTO_INCREMENT PRIMARY KEY,
    event_id INT,
    user_id INT,
    FOREIGN KEY (event_id) REFERENCES Events(event_id)
);
\end{lstlisting}
            \item \textit{Back-End (server.js)}:
\begin{lstlisting}[language=JavaScript, caption={RSVP with Capacity Check}]
app.post('/api/v1/events/:id/rsvp', authenticateToken, async (req, res) => {
    const eventId = req.params.id;
    const userId = req.user.user_id;
    const [eventRows] = await db.execute(
        'SELECT max_capacity, (SELECT COUNT(*) FROM Event_RSVPs WHERE event_id = ?) as rsvp_count FROM Events WHERE event_id = ?', 
        [eventId, eventId]
    );
    if (eventRows[0].rsvp_count >= eventRows[0].max_capacity) 
        return res.status(400).json({ error: 'Event is full' });
    await db.execute('INSERT INTO Event_RSVPs (event_id, user_id) VALUES (?, ?)', [eventId, userId]);
    res.status(201).json({ message: 'RSVP successful' });
});
\end{lstlisting}
            \item \textit{Front-End (script.js)}:
\begin{lstlisting}[language=JavaScript, caption={RSVP Action}]
async function loadEventDetails() {
    const response = await fetch(`http://localhost:5000/api/v1/events/${eventId}`, {
        headers: { 'Authorization': `Bearer ${token}` }
    });
    const event = await response.json();
    document.getElementById('rsvpBtn')?.addEventListener('click', async () => {
        const rsvpResponse = await fetch(`http://localhost:5000/api/v1/events/${eventId}/rsvp`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (rsvpResponse.ok) {
            showNotification('RSVP successful!');
            document.getElementById('rsvpBtn').style.display = 'none';
        } else {
            showNotification('Event is full!');
        }
    });
}
\end{lstlisting}
            \item \textit{Function and Working}: 
                After authentication, users browse events on \texttt{index.html} and RSVP via \texttt{event-details.html}. The back-end checks \texttt{rsvp\_count} against \texttt{max\_capacity}; if space exists, it adds to \texttt{Event\_RSVPs}. The front-end updates the UI, hiding the RSVP button on success or showing an error if full, leading to the waitlist feature next.
        \end{itemize}

    \item \textbf{Waitlist Automation}
        \begin{itemize}
            \item \textit{Database (SQL)}:
\begin{lstlisting}[language=SQL, caption={Waitlist and Trigger}]
CREATE TABLE Waitlist (
    waitlist_id INT AUTO_INCREMENT PRIMARY KEY,
    event_id INT,
    user_id INT,
    position INT NOT NULL,
    FOREIGN KEY (event_id) REFERENCES Events(event_id)
);
DELIMITER //
CREATE TRIGGER after_rsvp_delete
AFTER DELETE ON Event_RSVPs
FOR EACH ROW
BEGIN
    DECLARE next_user_id INT;
    DECLARE event_capacity INT;
    SELECT max_capacity INTO event_capacity FROM Events WHERE event_id = OLD.event_id;
    IF (SELECT COUNT(*) FROM Event_RSVPs WHERE event_id = OLD.event_id) < event_capacity THEN
        SELECT user_id INTO next_user_id FROM Waitlist 
        WHERE event_id = OLD.event_id ORDER BY position ASC LIMIT 1;
        IF next_user_id IS NOT NULL THEN
            INSERT INTO Event_RSVPs (event_id, user_id) VALUES (OLD.event_id, next_user_id);
            DELETE FROM Waitlist WHERE event_id = OLD.event_id AND user_id = next_user_id;
        END IF;
    END IF;
END//
DELIMITER ;
\end{lstlisting}
            \item \textit{Back-End (server.js)}:
\begin{lstlisting}[language=JavaScript, caption={Waitlist Addition}]
app.post('/api/v1/events/:id/waitlist', authenticateToken, async (req, res) => {
    const eventId = req.params.id;
    const userId = req.user.user_id;
    const [eventRows] = await db.execute(
        'SELECT max_capacity, (SELECT COUNT(*) FROM Event_RSVPs WHERE event_id = ?) as rsvp_count FROM Events WHERE event_id = ?', 
        [eventId, eventId]
    );
    if (eventRows[0].rsvp_count < eventRows[0].max_capacity) 
        return res.status(400).json({ error: 'Event is not full yet' });
    const [positionRows] = await db.execute(
        'SELECT COALESCE(MAX(position), 0) + 1 as next_position FROM Waitlist WHERE event_id = ?', 
        [eventId]
    );
    await db.execute('INSERT INTO Waitlist (event_id, user_id, position) VALUES (?, ?, ?)', 
        [eventId, userId, positionRows[0].next_position]);
    res.status(201).json({ message: 'Added to waitlist' });
});
\end{lstlisting}
            \item \textit{Front-End (script.js)}:
\begin{lstlisting}[language=JavaScript, caption={Waitlist Action}]
async function loadEventDetails() {
    document.getElementById('waitlistBtn')?.addEventListener('click', async () => {
        const response = await fetch(`http://localhost:5000/api/v1/events/${eventId}/waitlist`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }
        });
        if (response.ok) showNotification('Added to waitlist!');
        else showNotification('Already on waitlist!');
    });
}
\end{lstlisting}
            \item \textit{Function and Working}: 
                If an event is full, users join the waitlist via \texttt{POST /api/v1/events/:id/waitlist}, which assigns a \texttt{position}. When someone unjoins (\texttt{DELETE /api/v1/events/:id/rsvp}), the trigger \texttt{after\_rsvp\_delete} checks capacity and moves the first waitlisted user to \texttt{Event\_RSVPs}, deleting them from \texttt{Waitlist}. This follows RSVP attempts.
        \end{itemize}

    \item \textbf{Attendance Tracking}
        \begin{itemize}
            \item \textit{Database (SQL)}:
\begin{lstlisting}[language=SQL, caption={Attendance Table}]
CREATE TABLE Attendance (
    attendance_id INT AUTO_INCREMENT PRIMARY KEY,
    event_id INT,
    user_id INT,
    check_in_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (event_id) REFERENCES Events(event_id),
    UNIQUE KEY unique_attendance (event_id, user_id)
);
\end{lstlisting}
            \item \textit{Back-End (server.js)}:
\begin{lstlisting}[language=JavaScript, caption={Check-In Endpoint}]
app.post('/api/v1/events/:id/check-in', authenticateToken, async (req, res) => {
    const { code } = req.body;
    const [eventRows] = await db.execute('SELECT check_in_code FROM Events WHERE event_id = ?', [req.params.id]);
    if (eventRows[0].check_in_code !== code) 
        return res.status(400).json({ error: 'Invalid check-in code' });
    await db.execute('INSERT INTO Attendance (event_id, user_id) VALUES (?, ?)', 
        [req.params.id, req.user.user_id]);
    res.status(201).json({ message: 'Checked in successfully' });
});
\end{lstlisting}
            \item \textit{Front-End (script.js)}:
\begin{lstlisting}[language=JavaScript, caption={Check-In Logic}]
async function loadEventDetails() {
    const attendanceResponse = await fetch(`http://localhost:5000/api/v1/events/${eventId}/check-in`, {
        headers: { 'Authorization': `Bearer ${token}` }
    });
    const { hasAttended } = await attendanceResponse.json();
    if (hasAttended) document.getElementById('feedbackForm').style.display = 'block';
    document.getElementById('checkInBtn')?.addEventListener('click', async () => {
        const code = document.getElementById('checkInCode').value;
        const response = await fetch(`http://localhost:5000/api/v1/events/${eventId}/check-in`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ code })
        });
        if (response.ok) {
            showNotification('Checked in successfully!');
            document.getElementById('feedbackForm').style.display = 'block';
        } else {
            showNotification('Invalid code!');
        }
    });
}
\end{lstlisting}
            \item \textit{Function and Working}: 
                After RSVPing, users check in using a unique \texttt{check\_in\_code} via \texttt{POST /api/v1/events/:id/check-in}. The back-end validates the code and adds to \texttt{Attendance}. The front-end checks attendance status (\texttt{GET /api/v1/events/:id/check-in}) to show the feedback form only to attendees, occurring post-RSVP and before analytics.
        \end{itemize}

    \item \textbf{Analytics}
        \begin{itemize}
            \item \textit{Database (SQL)}:
\begin{lstlisting}[language=SQL, caption={Analytics Query}]
SELECT e.title, COUNT(a.attendance_id) as attendance_count
FROM Events e
LEFT JOIN Attendance a ON e.event_id = a.event_id
WHERE e.organizer_id = ?
GROUP BY e.event_id, e.title;
\end{lstlisting}
            \item \textit{Back-End (server.js)}:
\begin{lstlisting}[language=JavaScript, caption={Analytics Endpoint}]
app.get('/api/v1/analytics/attendance', authenticateToken, async (req, res) => {
    if (req.user.role !== 'organizer' && req.user.role !== 'admin') 
        return res.status(403).json({ error: 'Forbidden' });
    const [rows] = await db.execute(
        'SELECT e.title, COUNT(a.attendance_id) as attendance_count ' +
        'FROM Events e LEFT JOIN Attendance a ON e.event_id = a.event_id ' +
        'WHERE e.organizer_id = ? GROUP BY e.event_id, e.title', 
        [req.user.user_id]
    );
    res.json(rows);
});
\end{lstlisting}
            \item \textit{Front-End (script.js)}:
\begin{lstlisting}[language=JavaScript, caption={Analytics Visualization}]
function setupAnalytics() {
    fetch('http://localhost:5000/api/v1/analytics/attendance', {
        headers: { 'Authorization': `Bearer ${token}` }
    }).then(response => response.json()).then(data => {
        const ctx = document.getElementById('analyticsChart').getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: data.map(e => e.title),
                datasets: [{
                    label: 'Attendance',
                    data: data.map(e => e.attendance_count),
                    backgroundColor: '#1e90ff'
                }]
            },
            options: { scales: { y: { beginAtZero: true } } }
        });
    });
}
\end{lstlisting}
            \item \textit{Function and Working}: 
                After events occur and attendance is recorded, organizers/admins access analytics via \texttt{GET /api/v1/analytics/attendance}. The back-end queries \texttt{Events} and \texttt{Attendance}, aggregating counts by event. The front-end renders a bar chart with Chart.js, providing the final step in the flow for organizers to evaluate event success.
        \end{itemize}
\end{enumerate}

\subsection{Additional Details}
The system integrates these features seamlessly:
\begin{itemize}
    \item Users start with registration/login (Role-Based Access).
    \item They RSVP to events, constrained by capacity (Capacity Management).
    \item If full, they join the waitlist, which auto-promotes (Waitlist Automation).
    \item During events, they check in (Attendance Tracking).
    \item Post-event, organizers view attendance data (Analytics).
\end{itemize}

\section{Database Schema}
\begin{lstlisting}[language=SQL, caption={Sample Event}]
INSERT INTO Events (title, date_time, location, max_capacity, organizer_id, check_in_code) 
VALUES ('Tech Talk: AI Innovations', '2025-05-10 14:00:00', 'Zoom Meeting', 50, 1, 'AI2025TT');
\end{lstlisting}

\section{Website Access}
The project is accessible at: \\
\url{https://example.com/event-scheduler} \\
\textit{Note: Replace with the actual URL. Locally: \texttt{http://localhost:5000} (run \texttt{node server.js}).}

\section{Conclusion}
This project offers a comprehensive event management solution, with a clear code flow from authentication to analytics, ensuring usability and scalability.


\end{document}